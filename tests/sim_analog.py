#!/usr/bin/env python3
"""Simulate PCB reconstruction filter on PWM output and generate analog WAV files.

Reads tests/*.pwl files (generated by pwm_analog_tb.v) and simulates a 3rd-order
RC low-pass filter with DC blocking cap — the same circuit on the PCB.

    PWM pin ---[R1]---+---[R2]---+---[R3]---+---[Cac]---> Audio Out
                       |          |          |
                      [C1]       [C2]       [C3]       [Rload]
                       |          |          |             |
                      GND        GND        GND          GND

    R1=R2=R3=3.3k, C1=C2=C3=4.7nF, Cac=1uF, Rload=10k
    Per-stage fc = 1/(2*pi*3.3k*4.7nF) = 10.3 kHz

Forward Euler integration at dt=200 ns.
Output: tests/{name}_analog.wav for each tests/{name}.pwl
"""

import glob
import os
import sys
import wave

import numpy as np

# Circuit parameters
R1 = 3.3e3
R2 = 3.3e3
R3 = 3.3e3
C1 = 4.7e-9
C2 = 4.7e-9
C3 = 4.7e-9
CAC = 1e-6
RLOAD = 10e3


def load_pwl(path):
    """Load PWL file into time (seconds) and voltage arrays."""
    times, volts = [], []
    with open(path) as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) != 2:
                continue
            t_str, v_str = parts
            times.append(float(t_str.rstrip("n")) * 1e-9)
            volts.append(float(v_str))
    return np.array(times), np.array(volts)


def simulate_filter(t_pwl, v_pwl, dt):
    """Simulate 3rd-order RC LPF + DC blocking cap using forward Euler.

    Uses dt=200ns for speed (RC=15.5us so well within stability limit).
    Returns time, v_mid1, v_mid2, v_mid3, v_audio_out arrays.
    """
    t_end = t_pwl[-1]
    n_steps = int(t_end / dt) + 1
    t = np.linspace(0, t_end, n_steps)

    # Interpolate PWL input onto uniform grid
    v_in = np.interp(t, t_pwl, v_pwl)

    # Precompute coefficients
    dt_C1 = dt / C1
    dt_C2 = dt / C2
    dt_C3 = dt / C3
    dt_CAC = dt / CAC
    inv_R1 = 1.0 / R1
    inv_R2 = 1.0 / R2
    inv_R3 = 1.0 / R3
    inv_RL = 1.0 / RLOAD

    # State variables
    v1 = 0.0
    v2 = 0.0
    v3 = 0.0
    v_cac = 0.0

    v1_arr = np.zeros(n_steps)
    v2_arr = np.zeros(n_steps)
    v3_arr = np.zeros(n_steps)
    v_out_arr = np.zeros(n_steps)

    for i in range(n_steps):
        vin = v_in[i]
        v_audio = v3 - v_cac

        v1_arr[i] = v1
        v2_arr[i] = v2
        v3_arr[i] = v3
        v_out_arr[i] = v_audio

        i_r1 = (vin - v1) * inv_R1
        i_r2 = (v1 - v2) * inv_R2
        i_r3 = (v2 - v3) * inv_R3
        i_load = v_audio * inv_RL

        v1 += (i_r1 - i_r2) * dt_C1
        v2 += (i_r2 - i_r3) * dt_C2
        v3 += (i_r3 - i_load) * dt_C3
        v_cac += i_load * dt_CAC

    return t, v1_arr, v2_arr, v3_arr, v_out_arr


def write_wav(t_sim, v_audio, path, sample_rate=44100):
    """Resample audio output to WAV file (16-bit signed mono)."""
    duration = t_sim[-1]
    n_samples = int(duration * sample_rate)
    if n_samples < 1:
        print(f"  WARNING: Duration {duration*1e6:.0f} us too short for WAV")
        return False

    t_wav = np.linspace(0, duration, n_samples, endpoint=False)
    v_wav = np.interp(t_wav, t_sim, v_audio)

    # Normalize to 16-bit signed range
    v_max = max(abs(v_wav.max()), abs(v_wav.min()))
    if v_max > 0:
        v_norm = v_wav / v_max * 32000
    else:
        v_norm = v_wav

    samples = np.clip(v_norm, -32767, 32767).astype(np.int16)

    with wave.open(path, "w") as wf:
        wf.setnchannels(1)
        wf.setsampwidth(2)
        wf.setframerate(sample_rate)
        wf.writeframes(samples.tobytes())

    print(f"  WAV: {path} ({n_samples} samples, {duration:.4f} s, peak {v_max*1e3:.1f} mV)")
    return True


def generate_plot(t, v1, v2, v3, v_out, label, png_path):
    """Generate filter stages plot for one example waveform."""
    import matplotlib
    matplotlib.use("Agg")
    import matplotlib.pyplot as plt

    # Decimate for plotting
    dec = 10
    t_us = t[::dec] * 1e6

    fig, axes = plt.subplots(3, 1, figsize=(14, 8), sharex=True)
    fig.suptitle(
        f"SID PWM Analog Filter Simulation — {label}\n"
        f"3rd-order RC LPF (R=3.3k\u03a9, C=4.7nF \u00d73) + Cac=1\u00b5F + Rload=10k\u03a9",
        fontsize=12,
    )

    ax = axes[0]
    ax.plot(t_us, v1[::dec], color="#FF9800", linewidth=0.5)
    ax.set_ylabel("Voltage (V)")
    ax.set_title("Stage 1 — mid1 (after 1st RC)", fontsize=10)
    ax.grid(True, alpha=0.3)

    ax = axes[1]
    ax.plot(t_us, v2[::dec], color="#4CAF50", linewidth=0.5, label="mid2")
    ax.plot(t_us, v3[::dec], color="#9C27B0", linewidth=0.7, label="mid3")
    ax.set_ylabel("Voltage (V)")
    ax.set_title("Stages 2 & 3 — Progressive Carrier Rejection", fontsize=10)
    ax.legend(loc="upper right", fontsize=8)
    ax.grid(True, alpha=0.3)

    ax = axes[2]
    ax.plot(t_us, v_out[::dec], color="#E91E63", linewidth=0.6)
    ax.set_ylabel("Voltage (V)")
    ax.set_xlabel("Time (\u00b5s)")
    ax.set_title("Audio Output — AC-Coupled", fontsize=10)
    ax.axhline(y=0, color="gray", linewidth=0.5, linestyle="--")
    ax.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig(png_path, dpi=150, bbox_inches="tight")
    plt.close()
    print(f"  Plot: {png_path}")


def main():
    tests_dir = os.path.dirname(os.path.abspath(__file__))
    pwl_files = sorted(glob.glob(os.path.join(tests_dir, "*.pwl")))

    if not pwl_files:
        print("ERROR: No .pwl files found in tests/")
        print("Run the Verilog testbench first:")
        print("  iverilog -o tests/pwm_analog -g2005 src/tt_um_sid.v src/filter.v "
              "src/SVF_8bit.v src/pwm_audio.v tests/pwm_analog_tb.v")
        print("  vvp tests/pwm_analog")
        sys.exit(1)

    print(f"Found {len(pwl_files)} PWL files")
    dt = 200e-9  # 200 ns (RC=15.5 us, well within Euler stability)
    plot_generated = False

    for pwl_path in pwl_files:
        base = os.path.splitext(os.path.basename(pwl_path))[0]
        wav_path = os.path.join(tests_dir, base + "_analog.wav")

        print(f"\n{base}:")
        t_pwl, v_pwl = load_pwl(pwl_path)
        print(f"  PWL: {len(t_pwl)} points, {t_pwl[-1]*1e3:.1f} ms")

        t, v1, v2, v3, v_out = simulate_filter(t_pwl, v_pwl, dt)
        write_wav(t, v_out, wav_path)

        # Generate plot for first file as example
        if not plot_generated:
            png_path = os.path.join(tests_dir, "analog_filter_stages.png")
            generate_plot(t, v1, v2, v3, v_out, base, png_path)
            plot_generated = True

    print("\nDone.")


if __name__ == "__main__":
    main()
