#!/usr/bin/env python3
"""Simulate PWM audio recovery filter and plot the output.

Simulates the second-order RC low-pass filter from the documentation:

    uo_out[0] ---[R1]---+---[R2]---+---[Cac]---> Audio Out
                         |          |
                        [C1]       [C2]
                         |          |
                        GND        GND

    R1=R2=3.3k, C1=C2=4.7nF, Cac=1uF, Rload=10k

Uses scipy to solve the circuit ODEs with the PWL waveform as input.
The PWL file is generated by pwm_ngspice_tb.v (iverilog/vvp).
The ngspice netlist (pwm_filter.spice) is also provided for standalone use.
"""

import os
import sys
import numpy as np

# Circuit parameters
R1 = 3.3e3      # Ohm
R2 = 3.3e3      # Ohm
C1 = 4.7e-9     # F
C2 = 4.7e-9     # F
CAC = 1e-6      # F
RLOAD = 10e3    # Ohm


def load_pwl(path):
    """Load PWL file into time (seconds) and voltage arrays."""
    times, volts = [], []
    with open(path) as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) != 2:
                continue
            t_str, v_str = parts
            times.append(float(t_str.rstrip("n")) * 1e-9)
            volts.append(float(v_str))
    return np.array(times), np.array(volts)


def simulate_filter(t_pwl, v_pwl, dt):
    """Simulate 2nd-order RC LPF + DC blocking cap.

    State variables:
        v1 = voltage across C1 (node mid1)
        v2 = voltage across C2 (node mid2)
        v3 = voltage across Cac (mid2 side positive)

    KCL at mid1: (Vin - v1)/R1 = C1*dv1/dt + (v1 - v2)/R2
    KCL at mid2: (v1 - v2)/R2 = C2*dv2/dt + (v2 - v3 - vout)/0
        where vout = v_audio across Rload, and v_audio = (v2 - v3)*Rload/(Rload)
        Actually: current through Cac = Cac * d(v2 - v_audio)/dt = v_audio/Rload
        Let q = charge on Cac. v_cac = q/Cac. v_audio = v2 - v_cac.
        i_load = v_audio / Rload = (v2 - v_cac) / Rload
        dq/dt = i_load => Cac * dv_cac/dt = (v2 - v_cac) / Rload

    So the ODEs are:
        dv1/dt = (Vin - v1)/(R1*C1) - (v1 - v2)/(R2*C1)  ... wait, wrong

    Actually more carefully:
        C1 * dv1/dt = (Vin - v1)/R1 - (v1 - v2)/R2
        C2 * dv2/dt = (v1 - v2)/R2 - (v2 - v_cac)/Rload ... wait no

    The current through Cac and Rload in series:
        i = Cac * dv_cac/dt  and  v_audio = v2 - v_cac, i = v_audio/Rload

    So: Cac * dv_cac/dt = (v2 - v_cac) / Rload

    And for C2:
        C2 * dv2/dt = (v1 - v2)/R2 - i = (v1 - v2)/R2 - (v2 - v_cac)/Rload

    Returns time, v_pwm_interp, v_mid1, v_mid2, v_audio_out arrays.
    """
    t_end = t_pwl[-1]
    n_steps = int(t_end / dt) + 1
    t = np.linspace(0, t_end, n_steps)

    # Interpolate PWL input onto uniform grid
    v_in = np.interp(t, t_pwl, v_pwl)

    # State: v1 (C1 voltage), v2 (C2 voltage), v_cac (Cac voltage)
    v1 = 0.0
    v2 = 0.0
    v_cac = 0.0

    v1_arr = np.zeros(n_steps)
    v2_arr = np.zeros(n_steps)
    v_out_arr = np.zeros(n_steps)

    # Forward Euler integration (dt is small enough at 10 ns for ~10 kHz filter)
    for i in range(n_steps):
        vin = v_in[i]
        v_audio = v2 - v_cac

        v1_arr[i] = v1
        v2_arr[i] = v2
        v_out_arr[i] = v_audio

        # Derivatives
        i_r1 = (vin - v1) / R1
        i_r2 = (v1 - v2) / R2
        i_load = v_audio / RLOAD

        dv1 = (i_r1 - i_r2) / C1
        dv2 = (i_r2 - i_load) / C2
        dv_cac = i_load / CAC

        v1 += dv1 * dt
        v2 += dv2 * dt
        v_cac += dv_cac * dt

    return t, v_in, v1_arr, v2_arr, v_out_arr


def main():
    sim_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(sim_dir)

    pwl_path = os.path.join(sim_dir, "pwm_output.pwl")
    if not os.path.exists(pwl_path):
        print("ERROR: pwm_output.pwl not found in sim/ directory.")
        print("Run the Verilog testbench first:")
        print("  cd .. && iverilog -o pwm_ngspice_tb src/pwm_ngspice_tb.v "
              "src/tt_um_sid.v src/pwm_audio.v")
        print("  vvp pwm_ngspice_tb && mv pwm_output.pwl sim/")
        sys.exit(1)

    print("Loading PWL file...")
    t_pwl, v_pwl = load_pwl(pwl_path)
    print(f"  {len(t_pwl)} points, {t_pwl[-1]*1e6:.1f} us duration")

    # Simulate with 10 ns timestep (well below RC time constant ~15 us)
    dt = 10e-9
    print(f"Simulating filter (dt={dt*1e9:.0f} ns)...")
    t, v_in, v_mid1, v_mid2, v_out = simulate_filter(t_pwl, v_pwl, dt)
    print("Simulation complete.")

    time_us = t * 1e6

    # Decimate for plotting (every 10th point = 100 ns)
    dec = 10
    time_us_d = time_us[::dec]
    v_in_d = v_in[::dec]
    v_mid1_d = v_mid1[::dec]
    v_mid2_d = v_mid2[::dec]
    v_out_d = v_out[::dec]

    import matplotlib
    matplotlib.use("Agg")
    import matplotlib.pyplot as plt

    fig, axes = plt.subplots(3, 1, figsize=(14, 8), sharex=True)
    fig.suptitle(
        "SID 3-Voice PWM Output Filter Simulation\n"
        "Saw C4 + Pulse E4 + Tri G4 \u2014 "
        "2nd-order RC LPF (R=3.3k\u03a9, C=4.7nF) + Cac=1\u00b5F + Rload=10k\u03a9",
        fontsize=12,
    )

    # Panel 1: Raw PWM
    ax = axes[0]
    ax.plot(time_us_d, v_in_d, color="#2196F3", linewidth=0.2)
    ax.set_ylabel("Voltage (V)")
    ax.set_ylim(-0.1, 1.4)
    ax.set_title("uo_out[0] \u2014 Raw PWM (1.2 V, ~19.6 kHz carrier)", fontsize=10)
    ax.grid(True, alpha=0.3)

    # Panel 2: Filter stages
    ax = axes[1]
    ax.plot(time_us_d, v_mid1_d, color="#FF9800", linewidth=0.4, label="mid1 (after 1st RC)")
    ax.plot(time_us_d, v_mid2_d, color="#4CAF50", linewidth=0.6, label="mid2 (after 2nd RC)")
    ax.set_ylabel("Voltage (V)")
    ax.set_title("Filter Stage Voltages \u2014 Progressive Carrier Rejection", fontsize=10)
    ax.legend(loc="upper right", fontsize=8)
    ax.grid(True, alpha=0.3)

    # Panel 3: Audio output (AC-coupled)
    ax = axes[2]
    ax.plot(time_us_d, v_out_d, color="#E91E63", linewidth=0.6)
    ax.set_ylabel("Voltage (V)")
    ax.set_xlabel("Time (\u00b5s)")
    ax.set_title(
        "Audio Output \u2014 AC-Coupled (Cac=1\u00b5F, Rload=10k\u03a9)",
        fontsize=10,
    )
    ax.axhline(y=0, color="gray", linewidth=0.5, linestyle="--")
    ax.grid(True, alpha=0.3)

    plt.tight_layout()
    out_path = os.path.join(sim_dir, "pwm_filter_output.png")
    plt.savefig(out_path, dpi=150, bbox_inches="tight")
    print(f"Plot saved: {out_path}")


if __name__ == "__main__":
    main()
